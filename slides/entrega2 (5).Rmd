---
title: "Entrega II"
description: |
  Aplicando knn a hoteles
author:
  - name: Eva Barrio  (DNI 51417900-C)
    affiliation: Universidad Complutense de Madrid
    affiliation_url: 
date: "`r Sys.Date()`"
output:
    distill::distill_article:
        highlight: kate
        colorlinks: true
        code_folding: false
        toc: true            
        toc_depth: 3     
---

```{r setup, include = FALSE}
# Ajuste comunes de los chunk
knitr::opts_chunk$set(fig.width = 9, fig.asp = 1, out.width = "100%",
                      message = FALSE, warning = FALSE,
                      echo = TRUE, res = 400)
```

# Instrucciones (leer antes de empezar)

* Modifica dentro del documento `.Rmd` tus datos personales (nombre y DNI) ubicados en la cabecera del archivo.

* Aseg칰rate, **ANTES de seguir editando** el documento, que el archivo `.Rmd` se teje correctamente (bot칩n Knit) y se genera el `.html` correspondiente.

* Los chunks (cajas de c칩digo) creados est치n o vac칤os o incompletos, de ah칤 que la mayor칤a tengan la opci칩n `eval = FALSE`. Una vez que edites lo que consideres debes ir cambiando cada chunck a `eval = TRUE` para que se ejecuten.

* Recuerda que puedes ejecutar chunk a chunk con el bot칩n _play_ o ejecutar todos los chunk hasta uno dado (con el bot칩n a la izquierda del anterior).

## Obligatorio

Deber치s implementar un modelo de clasificaci칩n knn al conjunto hoteles. Tienes total libertad de decisi칩n pero los siguientes 칤tems son obligatorios

* Cualquier decisi칩n no justificada/argumentada de forma correcta no ser치 tenida en cuenta.

* Ser치 obligatorio un muestreo inicial.

* Deber치s implementar y detallar una fase 2-3 lo m치s completa posible

* Deber치s proponer al menos dos recetas distintas.

* Deber치s probar al menos una validaci칩n simple (haciendo uso de tune), asegur치ndote de que el mallado de par치metros es adecuado para afinar la b칰squeda de ese punto m칤nimo d la curva sesgo-varianza

* Deber치s probar al menos una validaci칩n cruzada v-folds paralelizada


# Datos {#datos}

Debes hacer uso del **dataset de reservas de hotel**

```{r}
library(tidyverse)
library(tidymodels)
hoteles_bruto <- read_csv(file = "./datos/hoteles.csv")
```

Los datos forman parte de un **conjunto de reservas de hotel** elaborado por Antonio et al., 2019 con 50 000 registros de reservas

游닄 **Detalle de variables**: <https://linkinghub.elsevier.com/retrieve/pii/S2352340918315191>

## An치lisis exploratorio inicial (num칠rico)

Antes de tomar ninguna decisi칩n con los datos lo primero que deber칤amos hacer es **echar un vistazo num칠rico** a c칩mo se comportan las variables. Dado que vamos a clasificar, lo primero que deber칤amos observar es como se distribuyen los niveles de nuestra variable objetivo.

### Variables

Lo primero es conocer las variables

```{r}
glimpse(hoteles_bruto)
```

* `hotel`: tipo de hotel (urbano o resort)
* `lead_time`: n칰mero de d칤as entre la reserva y la estancia.
* `stays_in_weekend_nights, stays_in_week_nights`: noches en fin de semana y entre semana
* `adults`: n칰mero de adultos
* `children`: 쯟a reserva tiene ni침os?
* `meal`: r칠gimen de comidas
* `country`: pa칤s de origen
* `market_segment`: segmento de mercado de la reserva
* `distribution_channel`: canal de distribuci칩n de la oferta
* `is_repeated_guest`: repite como hu칠sped?
* `previous_cancellations`: cancelaciones previas
* `previous_bookings_not_canceled`: reservas previas (no canceladas)
* `reserved_room_type, assigned_room_type`: tipo de habitaci칩n reservada/asignada
* `booking_changes`: cambios en la reserva
* `deposit_type`: tipo de dep칩sito
* `days_in_waiting_list`: d칤as en lista de espera
* `customer_type`: tipo de cliente
* `average_daily_rate`: tarifa media diaria
* `required_car_parking_spaces`: 쯣arking?
* `total_of_special_requests`: n칰mero de requisitos especiales demandados
* `arrival_date`: fecha de llegada 

### Balance de la variable objetivo

El objetivo ser치 **predecir si una reserva incluye ni침os/as o no**, por lo que `children` ser치 nuestra variable objetivo. Primer paso: conocer c칩mo se **distribuyen los niveles de la objetivo** (es binaria)


```{r}
# Objetivo: predecir si la reserva viene o no con ni침os
hoteles_bruto %>% 
  count(children) %>%
  mutate(porc = 100*n/sum(n))
```

### skim()

Adem치s con la funci칩n `skim()` del paquete `{skimr}` podemos **extraer algunas estad칤sticas b치sicas** de nuestros datos.

```{r skim}
library(skimr)
# Resumen num칠rico
hoteles_bruto %>% skim()
```

[Continua a partir de aqu칤 creando las secciones que consideres]

Se seguir치 la metodolog칤a SEMMA para acompa침ar la toma de decisiones que se necesiten para resolver el problema de clasificaci칩n presentado  **predecir si una reserva incluye ni침os/as o no** utilizando el aprendizaje supervisado y el algoritmo knn.


# Fase I. Sample. Muestreo.

```{r}
hoteles_bruto %>% 
  count(children) %>% 
  mutate (porc = 100*n/sum(n))
```

La proporci칩n entre reservas con ni침os y sin ni침os, entre estratos, es muy diferente, un 8.076 % con ni침os frente al 91.924 % sin ni침os. Por ello interesa un muestreo aleatorio estratificado que tendr치 en cuenta la misma proporci칩n de cada estrato evitando que la muestra se decante por las reservas sin ni침os.

En la primera prueba lo hacemos con el 20%

```{r}
hoteles_sample <-
  hoteles_bruto %>% 
  group_by(children) %>% 
  slice_sample (prop = 0.20) %>% 
  ungroup()
```

**Se preparan otras muestras para probar con otras proporciones el modelo.**

```{r}
hoteles_sample2 <-
  hoteles_bruto %>% 
  group_by(children) %>% 
  slice_sample (prop = 0.10) %>% 
  ungroup()
```

```{r}
hoteles_sample3 <-
  hoteles_bruto %>% 
  group_by(children) %>% 
  slice_sample (prop = 0.15) %>% 
  ungroup()
```


```{r}
hoteles_sample4 <-
  hoteles_bruto %>% 
  group_by(children) %>% 
  slice_sample (prop = 0.20) %>% 
  ungroup()
```


# Fase II. Explore. Explorar, visualizar y entender.

## Tipolog칤a de las variables

Se observa la tipolog칤a de las variables y se estudian de cara a resolver el problema e integrarlas en el algoritmo.

```{r}
skim(hoteles_bruto)
```

Tenemos 1 variable de tipo fecha, 11 variables de tipo num칠rico y 11 variables de tipo texto.


### Objetivo categ칩rica

El objetivo es conocer si las reservas tienen ni침os. La variable objetivo es children, que es de tipo character, no tiene valores missing, es binaria (2 valores 칰nicoa), su valor m칤nimo es 4 y el m치ximo 8 쯤u칠 significa?

### Predictoras num칠ricas

Las variables predictoras en el knn deben ser num칠ricas. Vamos por orden explorando todas las variables. 


**Las de tipo texto.**

```{r eval = FALSE}
hoteles_bruto %>% select(where(is.character)) %>% glimpse()
```

Todas son categor칤as de algo, de pa칤ses, del tipo de pensi칩n, tpo de cliente, etc. son de tipo cualitativas por lo que las pasamos a factores que es como R reconoce las variables cualitativas.

```{r}
hoteles <-
  hoteles_bruto %>% 
  mutate (across(where(is.character), as.factor))
hoteles
```

```{r}
skim(hoteles)
```


**La variable hotel** tiene dos tipos de datos. Es binaria.

```{r}
hoteles %>%
  count(hotel, sort = TRUE) %>% 
  mutate(porc=100*n/sum(n))
```

```{r}
hoteles %>% 
  group_by(hotel) %>% 
  count(children) %>% 
  mutate(prop = 100*n/sum(n)) %>% 
  ungroup()
```

La reserva con ni침os tiene algo m치s peso en el hotel tipo Resort, un 8.67% frente a un 7.70%, en ambos se mantienen las ratios de reservas con y sin ni침os globales.
No tocamos nada.

**La variable Children** es nuestra variable objetivo. 

**La variable meal** toma 5 valores.

```{r}
hoteles %>% 
  count(meal, sort=TRUE)
```

Podr칤an ordenarse por importancia y hay que decidir qu칠 hacer con los Undefined, se valora unirlo a SC. Antes se observa qu칠 pasa con los ni침os.

```{r}
hoteles %>% 
  group_by(meal) %>% 
  count(children) %>% 
  mutate(prop = n*100/sum(n)) %>% 
  ungroup()
```

La proporci칩n de ni침os con FB es la mayor un 18%. Con SC por su parte la menor con un 2% y los Undefined no dan informaci칩n.
Media Pensi칩n y solo desayuno tienen proporciones similares que se pueden agrupar.

Dentro de la receta: Se puede ordenar la variable.

```{r}
hoteles1 <-
  hoteles %>% 
  mutate(meal =
           factor(meal,
                  levels = c("Undefined", "SC", "BB", "HB", "FB"),
                  ordered = TRUE)) %>% 
  ifelse(meal == "Undefined", "SC", meal))
hoteles1
```

```{r}
hoteles %>% 
  mutate(pension = ifelse(meal == "Undefined", "SC", meal)) %>% 
  mutate(pension = factor (pension, levels = c("SC","BB","HB","FB"), ordered = TRUE))
```

**La orden ifelse para agrupar est치 mal. BORRAR!!! LO DEJO PARA PENSAR AL REPASAR**

Se observa de nuevo la proporci칩n de ni침os en la variable

```{r}
hoteles1 %>% 
  group_by(meal)  %>%  
  count(children)  %>%  
  mutate(porc = 100*n/sum(n)) %>% 
  ungroup()
```


```{r}
hoteles1 %>% 
  group_by(children)  %>%  
  count(meal)  %>%  
  mutate(porc = 100*n/sum(n)) %>% 
  ungroup()
```

```{r}
skim(hoteles1)
```

** La variable country **

Son 155 registros diferentes. Ser치 conveniente agruparlos para convertirla en num칠rica y optimizar el modelo de forma que luego necesitemos menos dummys. Para agruparlos se observa c칩mo se reparten las reservas con ni침os y c칩mo se distribuyen los datos.

Con una suma acumulada de la proporci칩n se observa que el 90% de las reservas se dan en los primeros 16 pa칤ses. Incluido Polonia se acumula el 90.690%, en este caso Polonia importa para el modelo.

```{r}
hoteles  %>% 
  count(country, sort = TRUE)  %>% 
  mutate(porc = 100*n/sum(n), cumul = cumsum(porc))
```

```{r}
hoteles %>% 
  count(country)  %>% 
  mutate(porc = 100*n/sum(n), cumul = cumsum(porc))
```

Observemos la proporci칩n de reservas con ni침os y sin ni침os por pa칤ses. 

```{r}
hoteles  %>% 
  group_by(country)  %>% 
  count(children, sort=TRUE)  %>%  
  mutate(porc_children = 100*n/sum(n))  %>%  
  ungroup()
```

```{r}
hoteles  %>% 
  group_by(country)  %>% 
  count(children, sort = TRUE)  %>%  
  mutate(porc_children = 100*n/sum(n))  %>%  
  ungroup() %>% 
  filter (children == "none")
```


Portugal, Espa침a, Francia, Gran Breta침a y Alemania est치n a la cabeza en n칰mero de reservas, sin embargo no todos est치n por encima del 8% en porcentaje de reservas con ni침os. Estos pa칤ses estar칤an dentro de los primeros 16 pa칤ses.

Interesa que las agrupaciones sean de elementos parecidos, que aporten similares datos o bien agrupar para tener un grupo del que el algoritmo pueda aprender.

La orden ifelse no se est치 utilizando bien. **REPASAR**

```{r}
hoteles %>% 
  group_by(country) %>% 
  count(children) %>% 
  mutate(prop = n*100/(sum(n))) %>% 
  ungroup() %>% 
  filter(prop>8, children=="children") %>% 
  mutate(mean = mean(prop))
```

**Opci칩n 1** Podr칤a agrupar los pa칤ses por continente. Pero perder칤a informaci칩n de hoteles en los que reservan muchos ni침os como Portugal

**Opci칩n 2** Entonces podr칤a agrupar los pa칤ses en funci칩n de los que acogen m치s ni침os o menos.
Simplificando podr칤an ser 2 grupos uno donde la proporci칩n de ni침os sea superior a 8 y otro donde sea inferior. Me dejar칤a en el bando de 0s los pa칤ses que acogen en valores absolutos m치s ni침os aunque con menos proporci칩n.

**Opci칩n 3** grupos formado por  pa칤ses en funci칩n de su porcentaje de reservas.

** REVISAR ESTE C칍DIGO**

```{r}
hoteles  %>% 
  mutate(country = fct_lump_prop(country, prop = 0.093,
                                other_level = "otros"))
hoteles
```
```{r}
skim(hoteles)
```

Decisi칩n:
- Se agrupan el 90.690% de las reservas se dan en los primeros 16 pa칤ses. Desde Portugal hasta Polonia. Grupo 1
- Se agrupan los pa칤ses con el 100% de reservas sin ni침os. Grupo 2.
- Se agrupan los pa칤ses con m치s del 8% de reservas con ni침os. Grupo 3.
- El grupo 4 es lo que queda.

**No USAR hoteles1. Se agrupa dentro de la receta**

**Variable market_segment**

```{r}
hoteles_bruto %>% 
  count(market_segment, sort = TRUE) %>% 
  mutate(prop = 100*n/sum(n), cumsum(prop))
```

De las 7 modalidades, Online_TA, Offline_TA/TO, Direct y Groups acumulan m치s del 93% de las reservas.
Veamos con ni침os.

```{r}
hoteles_bruto %>% 
  group_by(market_segment) %>% 
  count(children) %>% 
  mutate(prop = 100*n/sum(n)) %>% 
  ungroup()
```

Aviation, Groups y Corporate casi el 100% son reservas sin ni침os. Se agrupan estas por un lado. Grupo 1.

Y por otro lado, agrupar por market_segment con m치s del 8% de reservas con ni침os: Complementary, Direct y Online_TA grupo 2 y Offline_TA/TO por otro. Grupo 3.


**distribution_channel**

Tiene 5 modalidades una de ellas sin definir con 1 observacio칩n y un 0.002 de representatividad, junto con GDS que tiene 0.216 de representaci칩n son las menos representadas.

```{r}
hoteles %>% 
  count(distribution_channel) %>% 
  mutate(prop = 100*n/sum(n))
```

Veamos con ni침os.

```{r}
hoteles %>% 
  group_by(distribution_channel) %>% 
  count(children, sort=TRUE) %>%
  mutate (prop = 100*n/sum(n)) %>% 
  ungroup()
```

Undefined es una observaci칩n de reserva con ni침os. Y por su parte GDS es 100% sin ni침os. Representan muy poco.
TA/TO y Direct es el modo de distribuci칩n preferido para reservas con ni침os.

Por ello se podr칤an eliminar, al menos undefined.

**reserved_room_type	**

9 modalidades de habitaci칩n. La modalidad L solo tiene 2 observaciones, reservas sin ni침os.

```{r}
hoteles %>% 
  count(reserved_room_type) %>% 
  mutate (porc = 100*n/sum(n), cumsum(porc))
```

Con ni침os

```{r}
hoteles %>% 
  group_by(reserved_room_type) %>% 
  count(children, sort=TRUE) %>%
  mutate (prop = 100*n/sum(n)) %>% 
  ungroup()
```

**assigned_room_type	**	

10 modalidades. Diferentes son I, K de la anterior variable que adem치s tiene poco peso

```{r}
hoteles %>% 
  count(assigned_room_type, sort = TRUE) %>% 
  mutate (porc = 100*n/sum(n), cumsum(porc))
```

Con ni침os tanto I como K tienen reservas con ni침os, siendo I algo m치s representativa ya que supera el 8% de referencia.

```{r}
hoteles %>% 
  group_by(assigned_room_type) %>% 
  count(children) %>%
  mutate (prop = 100*n/sum(n)) %>% 
  ungroup()
```


**deposit_type		**

En este caso las reservas sin ni침os son mayoritarimente del tipo No_Deposit, casi no aporta informaci칩n por lo que se podr칤a eliminar la variable entera.

```{r}
hoteles %>% 
  count(deposit_type, sort = TRUE) %>% 
  mutate (porc = 100*n/sum(n), cumsum(porc))
```


```{r}
hoteles %>% 
  group_by(deposit_type) %>% 
  count(children) %>%
  mutate (prop = 100*n/sum(n)) %>% 
  ungroup()
```

**customer_type**

Tiene 4 modalidades y con las dos m치s numerosas se cubre el 95.546% de los datos con ambas y los ni침os estar칤an representados.

```{r}
hoteles %>% 
  count(customer_type, sort = TRUE) %>% 
  mutate (porc = 100*n/sum(n), cumsum(porc))
```


```{r}
hoteles %>% 
  group_by(customer_type) %>% 
  count(children) %>%
  mutate (prop = 100*n/sum(n)) %>% 
  ungroup()
```

**requiring_parking**

Una variable binaria que representa el n칰mero de plazas de aparcamiento. Si se reserva plaza el porcentaje es casi el doble en reservas con ni침os que sin reserva de plaza.

```{r}
hoteles %>% 
  count(required_car_parking_spaces, sort = TRUE) %>% 
  mutate (porc = 100*n/sum(n), cumsum(porc))
```


```{r}
hoteles %>% 
  group_by(required_car_parking_spaces) %>% 
  count(children) %>%
  mutate (prop = 100*n/sum(n)) %>% 
  ungroup()
```

**Las de tipo fecha**

La variable que informa de la fecha de llegada est치 almacenada como texto, la cambiamos a formato fecha, que en el fondo es un n칰mero, para poder trabajar con ella.


```{r eval = FALSE}
hoteles_bruto %>% mutate(arrival_date = as.Date(arrival_date))
```

```{r}
hoteles <- 
  hoteles_bruto %>% 
  mutate(m_arr = month(arrival_date), y_arr = year(arrival_date),
         wday_arr = wday(arrival_date))

hoteles  %>% 
  group_by(y_arr)  %>% 
  count(children)  %>%  
  mutate(porc = 100*n/sum(n))
```
El a침o no influye mucho, hay que mirar los meses y los fines de semana y festivos.

**Las de tipo num칠rico**



## Problemas de codificaci칩n o rango

VER SKIM

* `average_daily_rate`: es la 칰nica num칠rica continua pero tiene **valores negativos o cero** -6.38 (deber칤an ser estrictamente positivo) --> el 2.33% tiene **problemas de codificaci칩n o rango** que deberemos pasar a ausentes e imputarles un valores luego.

## Datos ausentes

## Valores at칤picos

## Importancia de las variables en relaci칩n con la variable objetivo. Dependencia entre variables cualitativas

M치s all치 del an치lisis exploratorio num칠rico, podemos ejecutar un contraste de independencia para tener mayor certeza de si la predictora es dependiente o no de la variable objetivo (si fuera independiente, no tendr칤a sentido mantenerla)

```{r}
chisq.test(hoteles$children, hoteles$hotel)
```

Con un nivel de significaci칩n igual a 0.05 y un p-valor < 0.05 se rechaza la hip칩tesis nula de independencia

Y con todas a la vez

```{r warning = FALSE}
chisq <-
  tibble("variable" = hoteles %>% 
           select(where(is.factor))  %>% 
           names(),
         "p_value" = hoteles  %>% 
           select(where(is.factor))  %>% 
           map_dbl(.f = function(x) { chisq.test(hoteles$children, x)$p.value}))
chisq  %>% 
  arrange(desc(p_value))
```

Y filtrando para un p-valor mayor del nivel marcado aparecen cero filas.

```{r warning = FALSE}
chisq  %>% 
  filter(p_value > 0.05)
```

No hay evidencia suficiente para decir que existe predictora independiente de la objetivo (al 95% de confianza) seg칰n la prueba de independencia realizada


## Analizar la relaci칩n entre las variables

Al analizar esta relaci칩n se busca una posible relaci칩n lineal, calculando una matriz de correlaciones. Solo se le pueden pasar las variables num칠ricas de la tabla

```{r}
library(corrr)
correlate(hoteles %>% 
            select(where(is.numeric)))
```

Para visualizarla

```{r}
library(corrplot)
cor_matrix <-
  cor(hoteles %>% 
        select(where(is.numeric)))
corrplot(cor_matrix)
```

No se observan correlaciones muy evidentes entre ninguna, quiz치s entre las estancias entre semana y en fin de semana o entre que sea un cliente que repite y que no haya hecho anulaciones antes. Me quedar칤a con la que m치s reservas con ni침os tuviera.


# Fase III. Modify. Modificar.

# Fase IV. Model. Modelizar.

# Fase V. Assess. Evaluar.

